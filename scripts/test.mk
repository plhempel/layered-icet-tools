#!/usr/bin/make -f

# Run tests.


# Check for required arguments.
ifndef BUILD
$(error Missing variable "BUILD", which must contain the path to CMake's build directory.)
endif


# Configuration.
.ONESHELL:
.SUFFIXES:


# Determine the absolute path of the project directory so tests can be run from anywhere.
ROOT := $(realpath $(dir $(lastword $(MAKEFILE_LIST)))..)

# Version controlled resource directory.
RES := $(ROOT)/res

# Directory for files generated by tests.
OUT := $(ROOT)/out/test

# Create subdirectories for test output.
$(OUT)/%/:
	@mkdir -p $@


# Tracks all defined test cases.
TESTS :=

# Add a test case.
# Arguments: name, prerequisites, recipe
define test_case
$(eval
# Register the test.
TESTS += $1

# Invoke test by name.
$1: $(OUT)/$1.log

# Local variables.
$1: ERR := $(OUT)/$1.err

# Run the test.
$(OUT)/$1.log: $2 | $(dir $(OUT)/$1)
	@printf '\e[1mRun\e[m $1\n'
	{ $3; } >$$@ 2>&1 \
	&& { rm -f $$(ERR);  printf '\e[1;32mOk\e[m  $$@\n'; } \
	|| { mv $$@ $$(ERR); printf '\e[1;31mErr\e[m $$(ERR)\n'; }
)
endef


# IceT libraries.
ICET_COMMON := $(wildcard $(BUILD)/lib/*IceTCore.* $(BUILD)/lib/*IceTMPI.*)
ICET_GL     := $(ICET_COMMON) $(wildcard $(BUILD)/lib/*IceTGL.*)
ICET_GL3    := $(ICET_GL)


# Add a test case provided by IceT.
# Arguments: exe suffix (after `icetTests_`), library names, name, number of processes
test_icet = $(call test_case,icet/$1/$3,\
	$(BUILD)/bin/icetTests_$1 $2,\
	mpirun -n $4 --oversubscribe $$< $3\
	)


test_icet_mpi = $(call test_icet,mpi,$(ICET_COMMON),$1,$2)

$(call test_icet_mpi,BackgroundCorrect,2)
$(call test_icet_mpi,CompressionSize,2)
$(call test_icet_mpi,FloatingViewport,2)
$(call test_icet_mpi,ImageConvert,2)
$(call test_icet_mpi,Interlace,2)
$(call test_icet_mpi,MaxImageSplit,2)
$(call test_icet_mpi,OddImageSizes,1)
$(call test_icet_mpi,OddProcessCounts,8)
$(call test_icet_mpi,PreRender,1)
$(call test_icet_mpi,RadixkrUnitTests,2)
$(call test_icet_mpi,RadixkUnitTests,2)
$(call test_icet_mpi,SimpleTiming,2)
$(call test_icet_mpi,SparseImageCopy,2)


test_icet_mpi_opengl = $(call test_icet,mpi_opengl,$(ICET_GL),$1,$2)

$(call test_icet_mpi_opengl,BlankTiles,2)
$(call test_icet_mpi_opengl,BoundsBehindViewer,2)
$(call test_icet_mpi_opengl,DisplayNoDraw,2)
$(call test_icet_mpi_opengl,RandomTransform,2)
$(call test_icet_mpi_opengl,SimpleExample,2)


test_icet_mpi_opengl3 = $(call test_icet,mpi_opengl3,$(ICET_GL3),$1,$2)

$(call test_icet_mpi_opengl3,SimpleExampleOGL3,2)


# Define a layered test image.
# Arguments: name, size, layers
define layer
$(eval
# Local variables.
$(OUT)/res/img/$1.raw: IN_FILES := $(3:%=$(RES)/img/%.png)

# Generate the fragment buffer.
$(OUT)/res/img/$1.raw: $(BUILD)/bin/layer $$(IN_FILES) | $(dir $(OUT)/res/img/$1)
	@$$< $2 $$(IN_FILES) > $$@ 2> $$@.err && rm $$@.err || rm $$@
)
endef

# Reference solution for image compression.
$(OUT)/res/img/%.sparse: $(BUILD)/bin/compress $(ICET_COMMON) $(OUT)/res/img/%.raw
	@$< < $(OUT)/res/img/$*.raw > $@ 2> $@.err && rm $@.err || rm $@

# Reference solution for image blending.
$(OUT)/res/img/%.blend: $(BUILD)/bin/blend $(ICET_COMMON) $(OUT)/res/img/%.raw
	@$< < $(OUT)/res/img/$*.raw > $@ 2> $@.err && rm $@.err || rm $@


# Add a test case for image compression.
# Arguments: name
define test_compress
$(eval
# Local variables.
img/compress/$1: OUT_FILE := $(OUT)/img/compress/$1.out

# Compress with IceT, then check against referene solution.
$(call test_case,img/compress/$1, \
	$(BUILD)/bin/icet-compress $(ICET_COMMON) $(OUT)/res/img/$1.sparse, \
	$$< < $(OUT)/res/img/$1.raw > $$(OUT_FILE) \
		&& cmp $$(OUT_FILE) $(OUT)/res/img/$1.sparse \
		&& rm $$(OUT_FILE) \
	)
)
endef

# Add a test case for image decompression.
# Arguments: name
define test_decompress
$(eval
# Local variables.
img/decompress/$1: OUT_FILE := $(OUT)/img/decompress/$1.out

# Decompress with IceT, then check against reference solution.
$(call test_case,img/decompress/$1, \
	$(BUILD)/bin/icet-decompress $(ICET_COMMON) $(OUT)/res/img/$1.sparse $(OUT)/res/img/$1.blend, \
	$$< < $(OUT)/res/img/$1.sparse > $$(OUT_FILE) \
		&& cmp $$(OUT_FILE) $(OUT)/res/img/$1.blend \
		&& rm $$(OUT_FILE) \
	)
)
endef

# Add test cases for compressing and decompressing an image.
# Arguments: name, size, layers
define test_image
$(call layer,$1,$2,$3)
$(call test_compress,$1)
$(call test_decompress,$1)
endef

$(call test_image,diag/r,5 5,diag/red)
$(call test_image,diag/rg,5 5,diag/red diag/green)
$(call test_image,diag/rgb,5 5,diag/red diag/green diag/blue)


# Add a test case for image blending with IceT using a specific compositing strategy.
# Arguments: name, number of processes, image size, strategy, layers, layer ranks
define test_blend_strategy
$(eval
# Local variables.
img/blend/$1: IN_FILES := $(5:%=$(RES)/img/%.png)
img/blend/$1: REF_FILE := $(OUT)/img/blend/$1.ref
img/blend/$1: OUT_FILE := $(OUT)/img/blend/$1.$4.out
)

$(call test_case,img/blend/$1, \
	$(BUILD)/bin/icet-blend \
		$(BUILD)/bin/blend \
		$(ICET_COMMON) \
		$$(IN_FILES), \
	mpirun -n $2 --oversubscribe $$< $3 $4 $$(join $(6:%=%:),$$(IN_FILES)) > $$(OUT_FILE) \
		&& { $(BUILD)/bin/layer $3 $$(IN_FILES) | $(BUILD)/bin/blend > $$(REF_FILE); } \
		&& cmp $$(OUT_FILE) $$(REF_FILE) \
		&& rm $$(OUT_File) $$(REF_FILE) \
	)
endef

# The names of IceT's single image compositing strategies as expected by `icet-blend`.
SINGLE_IMAGE_STRATEGIES := bswap tree radixk radixkr bswap-folding

# Add a test case for image blending with IceT using all compositing strategies.
# Arguments: name, number of processes, image size, layers, layer ranks
define test_blend
$(foreach strategy,\
	direct \
		$(SINGLE_IMAGE_STRATEGIES:%=sequential.%)\
		split \
		$(SINGLE_IMAGE_STRATEGIES:%=reduce.%)\
		vtree,\
	$(call test_blend_strategy,$1.$(strategy),$2,$3,$(strategy),$4,$5)\
	)
endef

$(call test_blend,diag/rgb,1,5 5,diag/red diag/green diag/blue,0 0 0)
$(call test_blend,diag/r0g1b0,2,5 5,diag/red diag/green diag/blue,0 1 0)


# If no target is selected, run all tests.
all: $(TESTS)
.DEFAULT_GOAL := all

# Delete files generated by tests.
clean:
	@rm -rf $(OUT)/


.SECONDEXPANSION:
# Workaround to use patterns in the second expansion of pattern rule prerequisites.
_ := %

# Run all tests of a group.
%/: $$(filter $$@$$_,$$(TESTS))
	@:
