#!/usr/bin/make -f

# Run tests.


# Check for required arguments.
ifndef BUILD
$(error Missing variable "BUILD", which must contain the path to CMake's build directory.)
endif


# Configuration.
.ONESHELL:
.SUFFIXES:


# Determine the absolute path of the project directory so tests can be run from anywhere.
ROOT := $(realpath $(dir $(lastword $(MAKEFILE_LIST)))..)

# Version controlled resource directory.
RES := $(ROOT)/res

# Directory for files generated by tests.
OUT := $(ROOT)/test/out/$(CONFIG)

# Create subdirectories for test output.
$(OUT)/%/:
	@mkdir -p $@


# Tracks all defined test cases.
TESTS :=

# Add a test case.
# Arguments: name, prerequisites, recipe
define test_case
$(eval
# Register the test.
TESTS += $1

# Invoke test by name.
$1: $(OUT)/$1.log

# Local variables.
$1: ERR := $(OUT)/$1.err

# Run the test.
$(OUT)/$1.log: $2 | $(dir $(OUT)/$1)
	@printf '\e[1mRun\e[m $1\n'
	rm -f $$@
	{ $3; } >$$(ERR) 2>&1 \
	&& { mv $$(ERR) $$@; printf '\e[1;32mOk\e[m  $$@\n'; } \
	|| { printf '\e[1;31mErr\e[m $$(ERR)\n'; }
)
endef


# Run a distributed program.
# Uses srun if available and mpirun otherwise.
# Arguments: number of processes, command
run_dist = $(if $(shell command -v srun),$\
	srun -n $1 $2,$\
	mpirun -n $1 --oversubscribe $2$\
	)


# IceT libraries.
ICET_COMMON := $(wildcard $(BUILD)/lib/*IceTCore.* $(BUILD)/lib/*IceTMPI.*)
ICET_GL     := $(ICET_COMMON) $(wildcard $(BUILD)/lib/*IceTGL.*)
ICET_GL3    := $(ICET_GL)


# Add a test case provided by IceT.
# Arguments: exe suffix (after `icetTests_`), library names, name, number of processes
test_icet = $(call test_case,icet/$1/$3,\
	$(BUILD)/bin/icetTests_$1 $2,\
	$(call run_dist,$4,$$< -logdebug $3)\
	)


test_icet_mpi = $(call test_icet,mpi,$(ICET_COMMON),$1,$2)

$(call test_icet_mpi,BackgroundCorrect,2)
$(call test_icet_mpi,CompressionSize,2)
$(call test_icet_mpi,FloatingViewport,2)
$(call test_icet_mpi,ImageConvert,2)
$(call test_icet_mpi,Interlace,2)
$(call test_icet_mpi,MaxImageSplit,8)
$(call test_icet_mpi,OddImageSizes,1)
$(call test_icet_mpi,OddProcessCounts,8)
$(call test_icet_mpi,PreRender,1)
$(call test_icet_mpi,RadixkrUnitTests,2)
$(call test_icet_mpi,RadixkUnitTests,2)
$(call test_icet_mpi,SimpleTiming,2)
$(call test_icet_mpi,SparseImageCopy,2)


$(shell test -f $(BUILD)/bin/icetTests_mpi_opengl)
ifeq ($(.SHELLSTATUS),0)
test_icet_mpi_opengl = $(call test_icet,mpi_opengl,$(ICET_GL),$1,$2)

$(call test_icet_mpi_opengl,BlankTiles,2)
$(call test_icet_mpi_opengl,BoundsBehindViewer,2)
$(call test_icet_mpi_opengl,DisplayNoDraw,2)
$(call test_icet_mpi_opengl,RandomTransform,2)
$(call test_icet_mpi_opengl,SimpleExample,2)
endif


$(shell test -f $(BUILD)/bin/icetTests_mpi_opengl3)
ifeq ($(.SHELLSTATUS),0)
test_icet_mpi_opengl3 = $(call test_icet,mpi_opengl3,$(ICET_GL3),$1,$2)

$(call test_icet_mpi_opengl3,SimpleExampleOGL3,2)
endif


# Generate a reference solution to compare IceT's output against.
# Arguments: name, reference implementation, input assembler, input size, input files
define reference_solution
$(eval
# Assemble input images into a single file, then generate the reference solution from that file.
$(OUT)/res/img/$1: $2 $3 $(ICET_COMMON) $5 \
		| $(dir $(OUT)/res/img/$1)
	@$3 $4 $5 | $2 $4 > $$@ 2> $$@.err \
	&& rm $$@.err \
	|| rm $$@
)
endef

# Track test image names, so they are only defined once.
TEST_IMAGES :=

# For a test image generate reference solutions, test compression and decompression.
# Arguments: name, input assembler, input size, input files
define test_image
# Ignore repeated definitions.
$(if $(findstring $1,$(TEST_IMAGES)),,$\
$(eval
# Register image.
TEST_IMAGES += $1

# Compress with IceT, then check against reference solution.
img/compress/$1: OUT_FILE := $(OUT)/img/compress/$1.out
$(call test_case,img/compress/$1,$\
	$(BUILD)/bin/icet-compress $2 $4 $(OUT)/res/img/$1.sparse,$\
	$2 $3 $4 | $$< $3 > $$(OUT_FILE) \
		&& cmp $$(OUT_FILE) $(OUT)/res/img/$1.sparse \
		&& rm $$(OUT_FILE)$\
	)
# Generate reference solution.
$(call reference_solution,$1.sparse,$(BUILD)/bin/compress,$2,$3,$4)

# Decompress with IceT, then check against reference solution.
img/decompress/$1: OUT_FILE := $(OUT)/img/decompress/$1.out
$(call test_case,img/decompress/$1,$\
	$(BUILD)/bin/icet-decompress $(ICET_COMMON) $(OUT)/res/img/$1.sparse $(OUT)/res/img/$1.blend,$\
	$$< < $(OUT)/res/img/$1.sparse > $$(OUT_FILE) \
		&& cmp $$(OUT_FILE) $(OUT)/res/img/$1.blend \
		&& rm $$(OUT_FILE)$\
	)
# Generate reference solution.
$(call reference_solution,$1.blend,$(BUILD)/bin/blend,$2,$3,$4)
)
)
endef


# The names of IceT's single image compositing strategies as expected by `icet-blend`.
SINGLE_IMAGE_STRATEGIES := bswap bswap-folding radixk

# Helper function to join a list of words into a single string with no spaces, see
# https://www.gnu.org/software/make/manual/make.html#Syntax-of-Functions.
# Arguments: words, separator
NIL :=
.   := $(NIL) $(NIL)
glue = $(subst $.,$2,$1)

# Add a test case for image blending with IceT using all strategies.
# Test cases for compression and decompression are created as well.
# Arguments: image name, input assembler, distribution name, program, number of processes,
#            image size, images [, image ranks]
define test_blend
$(eval
# Generate reference solutions, test compression and decompression.
$(call test_image,$1,$2,$6,$7)

# Create a target for each strategy.
$(foreach strategy,$(SINGLE_IMAGE_STRATEGIES:%=sequential/%),$\
# Local variables.
img/blend/$(strategy)/$1/$3: OUT_FILE := $(OUT)/img/blend/$(strategy)/$1/$3.out

# Blend the images, compare the output to the reference solution.
$(call test_case,img/blend/$(strategy)/$1/$3,$\
	$4 $(ICET_COMMON) $7 $(OUT)/res/img/$1.blend,$\
	$(call run_dist,$5,$4 $(strategy) $6 $$(join $(8:%=%:),$7)) > $$(OUT_FILE) \
		&& cmp $$(OUT_FILE) $(OUT)/res/img/$1.blend \
		&& rm $$(OUT_FILE)$\
	)
)
)
endef

# Test blending with PNG layers as input.
# Arguments: image name, number of processes, image size, images, image ranks
test_blend_png =$(call test_blend,$\
	$1,$\
	$(BUILD)/bin/layer,$\
	$(call glue,$5),$\
	$(BUILD)/bin/icet-blend-png,$\
	$2,$\
	$3,$\
	$(4:%=$(RES)/img/%.png),$\
	$5$\
	)

$(call test_blend_png,diag/rgb,1,5 5,diag/red diag/green diag/blue,0 0 0)
$(call test_blend_png,diag/rgb,2,5 5,diag/red diag/green diag/blue,0 1 0)
$(call test_blend_png,diag/rgb,3,5 5,diag/red diag/green diag/blue,0 1 2)
$(call test_blend_png,diag/rgbr,4,5 5,diag/red diag/green diag/blue diag/red,0 1 2 3)
$(call test_blend_png,diag/rgbr,2,5 5,diag/red diag/green diag/blue diag/red,0 1 0 1)

# Test blending with raw fragment buffers as input.
# Arguments: image name, distribution name, image size, images
test_blend_raw =$(call test_blend,$\
	$1,$\
	$(BUILD)/bin/merge,$\
	$2,$\
	$(BUILD)/bin/icet-blend-raw,$\
	$(words $4),$\
	$3,$\
	$(foreach p,$4,$(RES)/img/$p.color $(RES)/img/$p.depth)$\
	)

$(call test_blend_raw,rt/4,0123,1280 720,rt/4/0 rt/4/1 rt/4/2 rt/4/3)
$(call test_blend_raw,rt/8,01234567,1280 720,rt/8/0 rt/8/1 rt/8/2 rt/8/3 rt/8/4 rt/8/5 rt/8/6 rt/8/7)
$(call test_blend_raw,rt/8,62734015,1280 720,rt/8/6 rt/8/2 rt/8/7 rt/8/3 rt/8/4 rt/8/0 rt/8/1 rt/8/5)


# If no target is selected, run all tests.
all: $(TESTS)
.DEFAULT_GOAL := all

# Delete files generated by tests.
clean:
	@rm -rf $(OUT)/


.SECONDEXPANSION:
# Workaround to use patterns in the second expansion of pattern rule prerequisites.
_ := %

# Run all tests of a group.
%/: $$(filter $$@$$_,$$(TESTS))
	@:
